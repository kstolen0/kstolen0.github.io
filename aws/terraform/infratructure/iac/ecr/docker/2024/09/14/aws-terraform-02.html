<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/assets/normalize.css">
  <link rel="stylesheet" href="/assets/open-color.css">
  <link rel="stylesheet" href="/assets/monophase/styles.css">
  <link type="application/atom+xml" rel="alternate" href="https://kristianstolen.com/feed.xml" title="Stolen Ideas" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Getting Started with AWS and Terraform: 02 - Hosting a dockerized web service in our EC2 container | Stolen Ideas</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Getting Started with AWS and Terraform: 02 - Hosting a dockerized web service in our EC2 container" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this multi-part blog series we will learn how to create a modern enterprise ready web service in AWS using Terraform. In this post, we will deploy a Dockerized web service to ECR for our EC2 instance to host" />
<meta property="og:description" content="In this multi-part blog series we will learn how to create a modern enterprise ready web service in AWS using Terraform. In this post, we will deploy a Dockerized web service to ECR for our EC2 instance to host" />
<link rel="canonical" href="https://kristianstolen.com/aws/terraform/infratructure/iac/ecr/docker/2024/09/14/aws-terraform-02.html" />
<meta property="og:url" content="https://kristianstolen.com/aws/terraform/infratructure/iac/ecr/docker/2024/09/14/aws-terraform-02.html" />
<meta property="og:site_name" content="Stolen Ideas" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-09-14T08:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Getting Started with AWS and Terraform: 02 - Hosting a dockerized web service in our EC2 container" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-14T08:00:00+00:00","datePublished":"2024-09-14T08:00:00+00:00","description":"In this multi-part blog series we will learn how to create a modern enterprise ready web service in AWS using Terraform. In this post, we will deploy a Dockerized web service to ECR for our EC2 instance to host","headline":"Getting Started with AWS and Terraform: 02 - Hosting a dockerized web service in our EC2 container","mainEntityOfPage":{"@type":"WebPage","@id":"https://kristianstolen.com/aws/terraform/infratructure/iac/ecr/docker/2024/09/14/aws-terraform-02.html"},"url":"https://kristianstolen.com/aws/terraform/infratructure/iac/ecr/docker/2024/09/14/aws-terraform-02.html"}</script>
<!-- End Jekyll SEO tag -->


  <script async src="https://use.fontawesome.com/releases/v5.0.12/js/all.js"></script>
  
  

</head>

  <body>
    <div class="container">
      <header class="masthead">
  <div class="masthead-title">
    <a href="/" title="Home">Stolen Ideas</a>
    <small class="tagline">Thoughts and learnings about software development</small>
  </div>

  
</header>


      <main>
        <article class="post">
  <h1 class="post-title">Getting Started with AWS and Terraform: 02 - Hosting a dockerized web service in our EC2 container</h1>
  <div class="post-meta">
    <time datetime="2024-09-14T08:00:00+00:00" itemprop="datePublished">
      14 Sep 2024
    </time>
      <span> • </span>
      <span class="post-categories-section">
        <i class="post-categories-icon fas fa-folder"></i>
        <ul class="post-categories"><li>
              <span class="post-category">aws</span></li><li>
              <span class="post-category">Terraform</span></li><li>
              <span class="post-category">infratructure</span></li><li>
              <span class="post-category">IaC</span></li><li>
              <span class="post-category">ECR</span></li><li>
              <span class="post-category">Docker</span></li></ul>
      </span>
    
    
  </div>

  <p>Hello again! Welcome back to our multi-part blog series on getting started with AWS and Terraform.</p>

<p>In part two of this series, we’ll take our humble EC2 instance, deploy a web server image to it, and make it reachable from anywhere across the internet.</p>

<p>At the end of this post you should be able to:</p>

<ol>
  <li>Configure an Elastic Container Repository (ECR)</li>
  <li>Deploy a Docker Image to ECR</li>
  <li>Pull and run Docker Images from ECR onto an EC2 instance</li>
</ol>

<h2 id="prerequisites">Prerequisites</h2>

<ol>
  <li>Completed the steps from <a href="/_posts/2024-08-07-get-started-with-aws-tf-01.md">part 1</a>
    <ul>
      <li>The steps in this post follow directly from where we left off in the last post</li>
    </ul>
  </li>
  <li>Installed <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html">awscli</a>
    <ul>
      <li>We’ll be using the awscli locally to provide credentials to Docker to interact with AWS ECR</li>
    </ul>
  </li>
  <li>Installed <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a> (or at least the <a href="https://docs.docker.com/engine/install/">Docker Engine</a>)
    <ul>
      <li>We’ll be using <a href="https://www.docker.com/">Docker</a> to build a simple node application into a Docker image and push the image to AWS ECR</li>
    </ul>
  </li>
</ol>

<h2 id="step-1---create-an-ecr-repository">Step 1 - Create an ECR Repository</h2>

<p>In this step we’ll define our <a href="https://aws.amazon.com/ecr/">ECR</a> repository which will store our web server container images.</p>

<p>AWS ECR is a service for hosting container image repositories which can be used by services on the internet to pull and run container images.</p>

<p>As we may be applying and destroying our environment multiple times, it might be simpler to create this repository in another Terraform project.</p>

<p>Create a new directory alongside <code class="language-plaintext highlighter-rouge">infra</code> called <code class="language-plaintext highlighter-rouge">ecr</code>.</p>

<p>Add a <code class="language-plaintext highlighter-rouge">main.tf</code> and <code class="language-plaintext highlighter-rouge">aws-provider.tf</code> as shown in <a href="https://gist.github.com/kstolen0/e02a97e7c684c04743634999bb68b734">this gist</a>, replacing the aws provider keys and region with your own then run <code class="language-plaintext highlighter-rouge">terraform init</code>.</p>

<p>Create a new file called <code class="language-plaintext highlighter-rouge">ecr.tf</code> within the <code class="language-plaintext highlighter-rouge">ecr</code> directory and add the following:</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># /ecr/ecr.tf</span>

<span class="k">resource</span> <span class="s2">"aws_ecr_repository"</span> <span class="s2">"unicorn_api_ecr"</span> <span class="p">{</span>
  <span class="nx">name</span>                 <span class="p">=</span> <span class="s2">"unicorn-api"</span>
  <span class="nx">image_tag_mutability</span> <span class="p">=</span> <span class="s2">"MUTABLE"</span>
  
  <span class="nx">image_scanning_configuration</span> <span class="p">{</span>
    <span class="nx">scan_on_push</span> <span class="p">=</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">output</span> <span class="s2">"unicorn_api_ecr_uri"</span> <span class="p">{</span>
  <span class="nx">description</span> <span class="p">=</span> <span class="s2">"The uri of the unicorn api ecr repository"</span>
  <span class="nx">value</span>       <span class="p">=</span> <span class="nx">aws_ecr_repository</span><span class="p">.</span><span class="nx">unicorn_api_ecr</span><span class="p">.</span><span class="nx">repository_url</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Above we have defined a new <a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ecr_repository">aws_ecr_repository</a> resource and an output value of the repo uri which will be used to push and pull our container image.</p>

<p>The <code class="language-plaintext highlighter-rouge">image_tag_mutability</code> property controls whether tags can be reused.</p>

<p>When set to <code class="language-plaintext highlighter-rouge">MUTABLE</code>, tags can be reused, allowing clients to pull the latest image automatically (e.g. via the <code class="language-plaintext highlighter-rouge">latest</code> tag).</p>

<p>When set to <code class="language-plaintext highlighter-rouge">IMMUTABLE</code> tags are fixed to specific images which prevents automatic updates but provides clients with greater stability and control as the image wont change unless the tag itself is updated.</p>

<p>There are many risks associated with tag mutability.</p>

<ul>
  <li>An attacker could replace a trusted image with a malicious one</li>
  <li>An image could change during a deployment pipeline, tests could run against one image but the deployed image could be different. This is also known as a Time-of-Check to Time-of-Use (<a href="https://sysdig.com/blog/toctou-tag-mutability/">TOCTOU</a>) issue</li>
  <li>Additionally, there can be ambiguity with which image version is in production, which can make debugging issues tricky</li>
</ul>

<p>Tag immutability helps to mitigate these issues:</p>

<ul>
  <li>Once a tag has been associated to an image, it will always refer to the same image</li>
  <li>Deployed image versions can be more easily traced by referencing their tags</li>
  <li>Deployments are more stable. The image tag used for tests in pre-production reference the same image being deployed to production</li>
</ul>

<p>For the purposes of this exercise, we will set tag mutability to <code class="language-plaintext highlighter-rouge">MUTABLE</code> if only so we won’t need to update multiple scripts each time we want to change our web server. In general though, it is recommended to use immutable tags for a more reliable, and secure service.</p>

<p>The <code class="language-plaintext highlighter-rouge">scan_on_push</code> property controls whether images should be scanned for vulnerabilities upon being pushed to the repository. As it’s free to enable, we might as well do so in case it finds any <a href="https://cve.mitre.org/">CVEs</a>.</p>

<p>The <code class="language-plaintext highlighter-rouge">name</code> property should be self-evident.</p>

<p>Let’s run <code class="language-plaintext highlighter-rouge">terraform apply</code> to create this repository, and make note of the repository uri output.</p>

<h2 id="step-2---building-our-web-server-image-and-pushing-it-to-ecr">Step 2 - Building our web server image and pushing it to ECR</h2>

<p>Now that we’ve defined an ECR repo, we need a container image to host within the repo. This image could be whatever we want it to be, but in our case, let’s make it a simple node web api.</p>

<p>Here’s one I prepared earlier! Clone <a href="https://github.com/kstolen0/sample-node-project">this repo</a> and then navigate to the directory.</p>

<p>Create a new bash script named <code class="language-plaintext highlighter-rouge">build-and-push.sh</code> and add the following:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

aws <span class="nt">--profile</span> <span class="o">[</span>your-aws-cli-profile] ecr get-login-password <span class="nt">--region</span> <span class="o">[</span>region] | <span class="nb">sudo </span>docker login <span class="nt">--username</span> AWS <span class="nt">--password-stdin</span> <span class="o">[</span>ecr-uri]
<span class="nb">sudo </span>docker build <span class="nt">-t</span> unicorn-api <span class="nb">.</span>
<span class="nb">sudo </span>docker tag unicorn-api:latest <span class="o">[</span>ecr-uri]:latest
<span class="nb">sudo </span>docker push <span class="o">[</span>ecr-uri]:latest
aws <span class="nt">--profile</span> <span class="o">[</span>your-aws-cli-profile] ecr list-images <span class="nt">--repository-name</span> unicorn-api

</code></pre></div></div>
<p>We’ll also need to enable read/write/execute permissions on the script in order to run it.</p>

<p><code class="language-plaintext highlighter-rouge">chmod 700 build-and-push.sh</code></p>

<p>Now run the script and if all went well you should see the following output:</p>

<p><img src="/assets/getting-started-with-aws-tf-02/example-push-ecr-output.png" alt="console output from pushing an image container to ecr" /></p>

<h2 id="step-3---pull-the-ecr-image-onto-ec2-instance-and-run-it">Step 3 - Pull the ECR image onto EC2 instance and run it</h2>

<p>By now we should have an EC2 instance running in AWS and a container image hosted on ECR. Now we just need to run the image on our EC2 instance.</p>

<p>In order to achieve this we’ll need to:</p>
<ol>
  <li>Add a security egress rule to allow EC2 to connect to ECR</li>
  <li>Define a role to allow read access to ECR and assign it to our EC2 instance</li>
  <li>write another custom script to run on our instance which will pull the docker image and run it in its own Docker environment</li>
</ol>

<p>Lets define our security group rule first.</p>

<p>Open the <code class="language-plaintext highlighter-rouge">unicorn-api.tf</code> file and add the following egress rule:</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># /infra/unicorn-api.tf</span>

<span class="k">resource</span> <span class="s2">"aws_vpc_security_group_egress_rule"</span> <span class="s2">"allow_outgoing_https"</span> <span class="p">{</span>
  
  <span class="nx">security_group_id</span> <span class="p">=</span> <span class="nx">aws_security_group</span><span class="p">.</span><span class="nx">unicorn_api_security_group</span><span class="p">.</span><span class="nx">id</span>

  <span class="nx">description</span> <span class="p">=</span> <span class="s2">"allow egress via port 443"</span>
  <span class="nx">cidr_ipv4</span>   <span class="p">=</span> <span class="s2">"0.0.0.0/0"</span>
  <span class="nx">ip_protocol</span> <span class="p">=</span> <span class="s2">"tcp"</span>
  <span class="nx">from_port</span>   <span class="p">=</span> <span class="mi">443</span>
  <span class="nx">to_port</span>     <span class="p">=</span> <span class="mi">443</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This <a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpc_security_group_egress_rule">security group egress rule</a> allows our EC2 instance to make https requests over the internet. ECR operates over HTTPS which is why declare TCP and ports 443.</p>

<p>You can validate that this changed worked by sshing into you EC2 instance and connecting to a website over https, e.g. <code class="language-plaintext highlighter-rouge">curl https://www.google.com</code>.</p>

<blockquote>
  <p>Note: We’re allowing egress over HTTPS to any node on the internet when we only need to connect to ECR. As we learned in the previous blog post this violates <a href="https://www.cyberark.com/what-is/least-privilege/">the principle of least privilege</a>. There is an alternative to this, which is to create a <a href="https://docs.aws.amazon.com/whitepapers/latest/aws-privatelink/what-are-vpc-endpoints.html">VPC Endpoint</a> for connecting to the ECR Service and allowing egress to that endpoint but that is beyond the scope of this blog post.</p>
</blockquote>

<p>Now that we can connect to ECR, we need to provide access for our EC2 instance to run commands against ECR.</p>

<p>In your <code class="language-plaintext highlighter-rouge">infra</code> directory create a new file <code class="language-plaintext highlighter-rouge">iam.tf</code> and add the following:</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># /infra/iam.tf</span>

<span class="k">resource</span> <span class="s2">"aws_iam_role"</span> <span class="s2">"ec2_ecr_readonly_role"</span> <span class="p">{</span>
  <span class="nx">name</span>               <span class="p">=</span> <span class="s2">"ec2-ecr-role"</span>
  <span class="nx">assume_role_policy</span> <span class="p">=</span> <span class="k">data</span><span class="p">.</span><span class="nx">aws_iam_policy_document</span><span class="p">.</span><span class="nx">ec2_assume_role_policy</span><span class="p">.</span><span class="nx">json</span>

  <span class="nx">inline_policy</span> <span class="p">{</span>
    <span class="nx">name</span>   <span class="p">=</span> <span class="s2">"ecr-read-policy"</span>
    <span class="nx">policy</span> <span class="p">=</span> <span class="k">data</span><span class="p">.</span><span class="nx">aws_iam_policy_document</span><span class="p">.</span><span class="nx">ec2_container_registry_read_only</span><span class="p">.</span><span class="nx">json</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">data</span> <span class="s2">"aws_iam_policy_document"</span> <span class="s2">"ec2_assume_role_policy"</span> <span class="p">{</span>
  <span class="nx">statement</span> <span class="p">{</span>
    <span class="nx">actions</span> <span class="p">=</span> <span class="p">[</span><span class="s2">"sts:AssumeRole"</span><span class="p">]</span>

    <span class="nx">principals</span> <span class="p">{</span>
      <span class="nx">type</span>        <span class="p">=</span> <span class="s2">"Service"</span>
      <span class="nx">identifiers</span> <span class="p">=</span> <span class="p">[</span><span class="s2">"ec2.amazonaws.com"</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">data</span> <span class="s2">"aws_iam_policy_document"</span> <span class="s2">"ec2_container_registry_read_only"</span> <span class="p">{</span>
  <span class="nx">statement</span> <span class="p">{</span>
    <span class="nx">actions</span> <span class="p">=</span> <span class="p">[</span>
      <span class="s2">"ecr:GetAuthorizationToken"</span><span class="p">,</span>
      <span class="s2">"ecr:BatchGetImage"</span><span class="p">,</span>
      <span class="s2">"ecr:GetDownloadUrlForLayer"</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="nx">resources</span> <span class="p">=</span> <span class="p">[</span><span class="s2">"*"</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>What we have done is defined an <a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_role">aws_iam_role</a> and applied a couple of <a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_policy_document">aws_iam_policy_documents</a> which:</p>

<ol>
  <li>Define which services can assume this role (<code class="language-plaintext highlighter-rouge">ec2_assume_role_policy</code>). In this case only the EC2 service can assume the role</li>
  <li>Define the actions a service with role can perform (<code class="language-plaintext highlighter-rouge">ec2_container_registry_read_only</code>).</li>
</ol>

<p>Our EC2 service requires three actions:</p>
<ul>
  <li>one to allow the principal to authenticate with ECR</li>
  <li>one to query the manifest of a container image pulled from ECR</li>
  <li>one to query the download URLs of the the container image layers</li>
</ul>

<p>We’ve defined our role and appropriate policies for the role, now we need to apply it to our EC2 instance.</p>

<p>Open <code class="language-plaintext highlighter-rouge">unicorn-api.tf</code> and add the following resource:</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># /infra/unicorn-api.tf</span>

<span class="k">resource</span> <span class="s2">"aws_iam_instance_profile"</span> <span class="s2">"unicorn_api_iam_profile"</span> <span class="p">{</span>
  <span class="nx">name</span> <span class="p">=</span> <span class="s2">"unicorn-api-iam-profile"</span>
  <span class="nx">role</span> <span class="p">=</span> <span class="nx">aws_iam_role</span><span class="p">.</span><span class="nx">ec2_readonly_role</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now add the <a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_instance_profile">iam instance profile</a> to the aws instance.</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># /infra/unicorn-api.tf</span>

<span class="k">resource</span> <span class="s2">"aws_instance"</span> <span class="s2">"unicorn_api"</span> <span class="p">{</span>

  <span class="c1"># ...</span>

  <span class="nx">iam_instance_profile</span> <span class="p">=</span> <span class="nx">aws_iam_instance_profile</span><span class="p">.</span><span class="nx">unicorn_api_iam_profile</span><span class="p">.</span><span class="nx">name</span>
 
  <span class="c1"># ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Great! Now that we’ve defined the IAM role and applied it to our EC2 resource, we can define a script for our instance to run on start up which will pull the ECR image and run it in docker.</p>

<p>Create a new file in the <code class="language-plaintext highlighter-rouge">infra</code> directory, <code class="language-plaintext highlighter-rouge">init-unicorn-api.sh</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

aws ecr get-login-password <span class="nt">--region</span> <span class="o">[</span>region] | docker login <span class="nt">--username</span> AWS <span class="nt">--password-stdin</span> <span class="o">[</span>ecr repository url]
docker run <span class="nt">-p</span> 80:8080 <span class="o">[</span>ecr repository url]:latest
</code></pre></div></div>

<p>Add the script to the EC2 instance user data property:</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#! /infra/unicorn-api.tf</span>

<span class="k">resource</span> <span class="s2">"aws_iam_instance_profile"</span> <span class="s2">"unicorn_api_iam_profile"</span> <span class="p">{</span>
  <span class="c1"># ...</span>
  
  <span class="nx">user_data</span> <span class="p">=</span> <span class="nx">file</span><span class="p">(</span><span class="s2">"</span><span class="k">${</span><span class="nx">path</span><span class="p">.</span><span class="k">module}</span><span class="s2">/init-unicorn-api.sh"</span><span class="p">)</span>

  <span class="c1"># ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With all that setup, we should now have an EC2 instance running a simple web server listening on port 80. There’s just one final step to allow this service to be reachable from any device on the internet.</p>

<h2 id="step-4---allow-any-device-on-the-internet-to-connect-to-our-web-server">Step 4 - Allow any device on the internet to connect to our web server</h2>

<p>So far we’ve created a web service Docker image, pushed the image to ECR, and pulled &amp; run the image on our EC2 instance.</p>

<p>Now we need to revisit our security group rules and update our ingress rule to allow incoming connections from any IP over port 80. Remove your existing ingress rule and replace it with the following.</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># /infra/unicorn-api.tf</span>

<span class="k">resource</span> <span class="s2">"aws_vpc_security_group_ingress_rule"</span> <span class="s2">"allow_incoming_http"</span> <span class="p">{</span>
  <span class="nx">security_group_id</span> <span class="p">=</span> <span class="nx">aws_security_group</span><span class="p">.</span><span class="nx">unicorn_api_security_group</span><span class="p">.</span><span class="nx">id</span>
  <span class="nx">description</span>       <span class="p">=</span> <span class="s2">"allow ingress via port 80"</span>
  <span class="nx">cidr_ipv4</span>         <span class="p">=</span> <span class="s2">"0.0.0.0/0"</span>
  <span class="nx">ip_protocol</span>       <span class="p">=</span> <span class="s2">"tcp"</span>
  <span class="nx">from_port</span>         <span class="p">=</span> <span class="mi">80</span>
  <span class="nx">to_port</span>           <span class="p">=</span> <span class="mi">80</span>
<span class="p">}</span>

</code></pre></div></div>

<p>With all of that we can run <code class="language-plaintext highlighter-rouge">terraform apply</code> to apply our changes.</p>

<p>Copy the EC2 public domain name output into a browser (you may need to prepend <code class="language-plaintext highlighter-rouge">http://</code> to the address as your browser might assume to use https) and see your awesome website!</p>

<p><img src="/assets/getting-started-with-aws-tf-02/hello-world.png" alt="a really really really cool website" /></p>

<p>Great! We’ve deployed a <code class="language-plaintext highlighter-rouge">Hello World!</code> web site to AWS!</p>

<p>Our domain name kinda sucks though, not to mention it will change every time we deploy changes, which isn’t ideal for keeping people coming back to our website.</p>

<p>In the next post we’ll look at how to configure a domain name for our web site so we no longer have to rely on our EC2 domain name.</p>

<p><a href="https://github.com/kstolen0/getting-started-with-aws-tf/tree/post-2">See here</a> to get the final code output from this post.</p>


  
</article>


  <aside class="related">
    <h2 class="related-title">Related posts</h2>
    <ul class="related-posts">
      
        <li>
          <a href="/aws/terraform/infratructure/iac/2024/08/07/get-started-with-aws-tf-01.html">
            Getting Started with AWS and Terraform: 01 - Creating an EC2 Instance
          </a>
          <small><time datetime="2024-08-07T08:00:00+00:00">07 Aug 2024</time></small>
        </li>
      
        <li>
          <a href="/javascript/math/numbers/ieee-754/floating/point/2024/03/17/floating-point-numbers.html">
            0.1 + 0.2 or I Dont Understand Floating Point Numbers
          </a>
          <small><time datetime="2024-03-17T08:00:00+00:00">17 Mar 2024</time></small>
        </li>
      
        <li>
          <a href="/node/nodejs/typescript/jest/tsconfig/git/2023/06/24/node-ts-initialisation.html">
            Create a NodeJS project with Typescript & Jest
          </a>
          <small><time datetime="2023-06-24T16:00:00+00:00">24 Jun 2023</time></small>
        </li>
      
    </ul>
  </aside>


      </main>

      <footer class="footer">
  <div class="footer-column">
    <p>
      <small>
        &copy;&nbsp;<time datetime="2022-12-04T08:00:00+00:00">2022</time>-<time datetime="2024-10-02T13:14:27+00:00">2024</time>. All right reserved.
      </small>
    </p>
    <p>
      <small>
        Powered by <a href="https://jekyllrb.com/" target="_blank">Jekyll</a> & <a href="https://github.com/zivhub/monophase" target="_blank">Monophase</a>
      </small>
    </p>
  </div>
  
    <div class="footer-column">
      <ul class="social-icons">
        
          <li class="social-icon-item">
            <a class="social-icon" href="mailto:kristian@kristianstolen.com" target="_blank">
              <i class="fas fa-envelope" title="Email"></i>
            </a>
          </li>
        
          <li class="social-icon-item">
            <a class="social-icon" href="https://github.com/kstolen0" target="_blank">
              <i class="fab fa-github" title="GitHub"></i>
            </a>
          </li>
        
          <li class="social-icon-item">
            <a class="social-icon" href="https://www.linkedin.com/in/kstolen" target="_blank">
              <i class="fab fa-linkedin" title="LinkedIn"></i>
            </a>
          </li>
        
          <li class="social-icon-item">
            <a class="social-icon" href="/feed.xml" target="_blank">
              <i class="fas fa-rss" title="RSS"></i>
            </a>
          </li>
        
      </ul>
    </div>
  
</footer>

    </div>

    

    
  </body>
</html>
